/** @module parser */

"use strict";

const irc = require("./irc");

module["exports"] = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "Message": parse_Message,
        "Prefix": parse_Prefix,
        "Server": parse_Server,
        "Person": parse_Person,
        "Nick": parse_Nick,
        "User": parse_User,
        "Host": parse_Host,
        "Command": parse_Command,
        "Params": parse_Params,
        "Middle": parse_Middle,
        "Trailing": parse_Trailing,
        "NonTerminating": parse_NonTerminating,
        "SquareBrackets": parse_SquareBrackets,
        "CurlyBrackets": parse_CurlyBrackets,
        "AlphaNum": parse_AlphaNum,
        "Letter": parse_Letter,
        "Num": parse_Num,
        "CRLF": parse_CRLF,
        "Space": parse_Space,
        "Channel": parse_Channel,
        "Mode": parse_Mode
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "Message";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_Message() {
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_Prefix();
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          r4 = parse_Command();
          if (r4 !== null) {
            r5 = parse_Params();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_CRLF();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = (function(offset, prefix, command, params) {
              return new irc.Message(prefix || null, command, params || []);
            })(r1, r3, r4, r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_Prefix() {
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 58) {
          r3 = ":";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_Server();
          if (r4 === null) {
            r4 = parse_Person();
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = (function(offset, prefix) {
            return prefix;
          })(r1, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_Server() {
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r4 = parse_AlphaNum();
        if (r4 === null) {
          r4 = parse_SquareBrackets();
          if (r4 === null) {
            if (/^[\-_.|*]/.test(input.charAt(pos))) {
              r4 = input.charAt(pos);
              pos++;
            } else {
              r4 = null;
              if (reportFailures === 0) {
                matchFailed("[\\-_.|*]");
              }
            }
          }
        }
        if (r4 !== null) {
          r3 = [];
          while (r4 !== null) {
            r3.push(r4);
            r4 = parse_AlphaNum();
            if (r4 === null) {
              r4 = parse_SquareBrackets();
              if (r4 === null) {
                if (/^[\-_.|*]/.test(input.charAt(pos))) {
                  r4 = input.charAt(pos);
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed("[\\-_.|*]");
                  }
                }
              }
            }
          }
        } else {
          r3 = null;
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_User();
          if (r4 === null) {
            r4 = parse_Host();
          }
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r5 = parse_Space();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = (function(offset, server) {
            return new irc.Server(server.join(""));
          })(r1, r3);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_Person() {
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_Nick();
        if (r3 !== null) {
          r5 = pos;
          r6 = parse_User();
          r6 = r6 !== null ? r6 : "";
          if (r6 !== null) {
            r7 = parse_Host();
            if (r7 !== null) {
              r4 = [r6, r7];
            } else {
              r4 = null;
              pos = r5;
            }
          } else {
            r4 = null;
            pos = r5;
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r5 = parse_Space();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = (function(offset, nick, userHost) {
            const user = userHost ? userHost[0] : null;
            const host = userHost ? userHost[1] : null;
            return irc.person(nick, user || null, host || null);
          })(r1, r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_Nick() {
        var r0, r1, r2;
        
        r1 = pos;
        r2 = parse_AlphaNum();
        if (r2 === null) {
          r2 = parse_SquareBrackets();
          if (r2 === null) {
            r2 = parse_CurlyBrackets();
            if (r2 === null) {
              if (/^[\-_^|\\`]/.test(input.charAt(pos))) {
                r2 = input.charAt(pos);
                pos++;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\-_^|\\\\`]");
                }
              }
            }
          }
        }
        if (r2 !== null) {
          r0 = [];
          while (r2 !== null) {
            r0.push(r2);
            r2 = parse_AlphaNum();
            if (r2 === null) {
              r2 = parse_SquareBrackets();
              if (r2 === null) {
                r2 = parse_CurlyBrackets();
                if (r2 === null) {
                  if (/^[\-_^|\\`]/.test(input.charAt(pos))) {
                    r2 = input.charAt(pos);
                    pos++;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed("[\\-_^|\\\\`]");
                    }
                  }
                }
              }
            }
          }
        } else {
          r0 = null;
        }
        if (r0 !== null) {
          r0 = (function(offset, chars) {
            return chars.join("");
          })(r1, r0);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_User() {
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 33) {
          r3 = "!";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (r3 !== null) {
          r5 = parse_AlphaNum();
          if (r5 === null) {
            r5 = parse_SquareBrackets();
            if (r5 === null) {
              if (/^[\-_=.~^\\`]/.test(input.charAt(pos))) {
                r5 = input.charAt(pos);
                pos++;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\-_=.~^\\\\`]");
                }
              }
            }
          }
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              r5 = parse_AlphaNum();
              if (r5 === null) {
                r5 = parse_SquareBrackets();
                if (r5 === null) {
                  if (/^[\-_=.~^\\`]/.test(input.charAt(pos))) {
                    r5 = input.charAt(pos);
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("[\\-_=.~^\\\\`]");
                    }
                  }
                }
              }
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = (function(offset, chars) {
            return chars.join("");
          })(r1, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_Host() {
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 64) {
          r3 = "@";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"@\"");
          }
        }
        if (r3 !== null) {
          r5 = parse_AlphaNum();
          if (r5 === null) {
            r5 = parse_SquareBrackets();
            if (r5 === null) {
              if (/^[\-_.|:\/]/.test(input.charAt(pos))) {
                r5 = input.charAt(pos);
                pos++;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\-_.|:\\/]");
                }
              }
            }
          }
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              r5 = parse_AlphaNum();
              if (r5 === null) {
                r5 = parse_SquareBrackets();
                if (r5 === null) {
                  if (/^[\-_.|:\/]/.test(input.charAt(pos))) {
                    r5 = input.charAt(pos);
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("[\\-_.|:\\/]");
                    }
                  }
                }
              }
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = (function(offset, chars) {
            return chars.join("");
          })(r1, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_Command() {
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = parse_Letter();
        if (r2 !== null) {
          r0 = [];
          while (r2 !== null) {
            r0.push(r2);
            r2 = parse_Letter();
          }
        } else {
          r0 = null;
        }
        if (r0 === null) {
          r2 = pos;
          r3 = parse_Num();
          if (r3 !== null) {
            r4 = parse_Num();
            if (r4 !== null) {
              r5 = parse_Num();
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        }
        if (r0 !== null) {
          r0 = (function(offset, chars) { return chars.join(""); })(r1, r0);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_Params() {
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_Space();
        if (r3 !== null) {
          r4 = [];
          r5 = parse_Middle();
          while (r5 !== null) {
            r4.push(r5);
            r5 = parse_Middle();
          }
          if (r4 !== null) {
            r5 = parse_Trailing();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = (function(offset, middle, trailing) {
            const params = middle;
            if (trailing) {
              params.push(trailing);
            }
            return params;
          })(r1, r4, r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_Middle() {
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = pos;
        r2 = pos;
        r5 = pos;
        r7 = pos;
        reportFailures++;
        if (input.charCodeAt(pos) === 58) {
          r6 = ":";
          pos++;
        } else {
          r6 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        reportFailures--;
        if (r6 === null) {
          r6 = "";
        } else {
          r6 = null;
          pos = r7;
        }
        if (r6 !== null) {
          r8 = pos;
          reportFailures++;
          r7 = parse_Space();
          reportFailures--;
          if (r7 === null) {
            r7 = "";
          } else {
            r7 = null;
            pos = r8;
          }
          if (r7 !== null) {
            r8 = parse_NonTerminating();
            if (r8 !== null) {
              r4 = [r6, r7, r8];
            } else {
              r4 = null;
              pos = r5;
            }
          } else {
            r4 = null;
            pos = r5;
          }
        } else {
          r4 = null;
          pos = r5;
        }
        if (r4 !== null) {
          r3 = [];
          while (r4 !== null) {
            r3.push(r4);
            r5 = pos;
            r7 = pos;
            reportFailures++;
            if (input.charCodeAt(pos) === 58) {
              r6 = ":";
              pos++;
            } else {
              r6 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            reportFailures--;
            if (r6 === null) {
              r6 = "";
            } else {
              r6 = null;
              pos = r7;
            }
            if (r6 !== null) {
              r8 = pos;
              reportFailures++;
              r7 = parse_Space();
              reportFailures--;
              if (r7 === null) {
                r7 = "";
              } else {
                r7 = null;
                pos = r8;
              }
              if (r7 !== null) {
                r8 = parse_NonTerminating();
                if (r8 !== null) {
                  r4 = [r6, r7, r8];
                } else {
                  r4 = null;
                  pos = r5;
                }
              } else {
                r4 = null;
                pos = r5;
              }
            } else {
              r4 = null;
              pos = r5;
            }
          }
        } else {
          r3 = null;
        }
        if (r3 !== null) {
          r4 = parse_Space();
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = (function(offset, param) {
            return param.map(function(part) { return part[2]; }).join("");
          })(r1, r3);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_Trailing() {
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 58) {
          r3 = ":";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (r3 !== null) {
          r4 = [];
          r5 = parse_NonTerminating();
          if (r5 === null) {
            r5 = parse_Space();
          }
          while (r5 !== null) {
            r4.push(r5);
            r5 = parse_NonTerminating();
            if (r5 === null) {
              r5 = parse_Space();
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = (function(offset, param) {
            return param[0] + param[1].join("");
          })(r1, r0);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_NonTerminating() {
        var r0;
        
        if (/^[^\n\r]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[^\\n\\r]");
          }
        }
        return r0;
      }
      
      function parse_SquareBrackets() {
        var r0;
        
        if (/^[[\]]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[[\\]]");
          }
        }
        return r0;
      }
      
      function parse_CurlyBrackets() {
        var r0;
        
        if (/^[{}]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[{}]");
          }
        }
        return r0;
      }
      
      function parse_AlphaNum() {
        var r0;
        
        r0 = parse_Letter();
        if (r0 === null) {
          r0 = parse_Num();
        }
        return r0;
      }
      
      function parse_Letter() {
        var r0;
        
        if (/^[a-zA-Z]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z]");
          }
        }
        return r0;
      }
      
      function parse_Num() {
        var r0;
        
        if (/^[0-9]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        return r0;
      }
      
      function parse_CRLF() {
        var r0, r1, r2, r3;
        
        r1 = pos;
        if (/^[\r]/.test(input.charAt(pos))) {
          r2 = input.charAt(pos);
          pos++;
        } else {
          r2 = null;
          if (reportFailures === 0) {
            matchFailed("[\\r]");
          }
        }
        if (r2 !== null) {
          if (/^[\n]/.test(input.charAt(pos))) {
            r3 = input.charAt(pos);
            pos++;
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("[\\n]");
            }
          }
          if (r3 !== null) {
            r0 = [r2, r3];
          } else {
            r0 = null;
            pos = r1;
          }
        } else {
          r0 = null;
          pos = r1;
        }
        return r0;
      }
      
      function parse_Space() {
        var r0, r1;
        
        if (/^[ ]/.test(input.charAt(pos))) {
          r1 = input.charAt(pos);
          pos++;
        } else {
          r1 = null;
          if (reportFailures === 0) {
            matchFailed("[ ]");
          }
        }
        if (r1 !== null) {
          r0 = [];
          while (r1 !== null) {
            r0.push(r1);
            if (/^[ ]/.test(input.charAt(pos))) {
              r1 = input.charAt(pos);
              pos++;
            } else {
              r1 = null;
              if (reportFailures === 0) {
                matchFailed("[ ]");
              }
            }
          }
        } else {
          r0 = null;
        }
        return r0;
      }
      
      function parse_Channel() {
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 33) {
          r3 = "!";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (r3 === null) {
          if (input.charCodeAt(pos) === 35) {
            r3 = "#";
            pos++;
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"#\"");
            }
          }
          if (r3 === null) {
            if (input.charCodeAt(pos) === 38) {
              r3 = "&";
              pos++;
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (r3 === null) {
              if (input.charCodeAt(pos) === 43) {
                r3 = "+";
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"+\"");
                }
              }
            }
          }
        }
        if (r3 !== null) {
          if (/^[^\x07 ,:]/.test(input.charAt(pos))) {
            r5 = input.charAt(pos);
            pos++;
          } else {
            r5 = null;
            if (reportFailures === 0) {
              matchFailed("[^\\x07 ,:]");
            }
          }
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              if (/^[^\x07 ,:]/.test(input.charAt(pos))) {
                r5 = input.charAt(pos);
                pos++;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("[^\\x07 ,:]");
                }
              }
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = (function(offset, channel) {
            const name = channel[0] + channel[1].join("");
            return irc.channel(name);
          })(r1, r0);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      function parse_Mode() {
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r3 = pos;
        if (input.charCodeAt(pos) === 43) {
          r4 = "+";
          pos++;
        } else {
          r4 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (r4 === null) {
          if (input.charCodeAt(pos) === 45) {
            r4 = "-";
            pos++;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
        }
        if (r4 !== null) {
          r6 = parse_Letter();
          if (r6 !== null) {
            r5 = [];
            while (r6 !== null) {
              r5.push(r6);
              r6 = parse_Letter();
            }
          } else {
            r5 = null;
          }
          if (r5 !== null) {
            r2 = [r4, r5];
          } else {
            r2 = null;
            pos = r3;
          }
        } else {
          r2 = null;
          pos = r3;
        }
        if (r2 !== null) {
          r0 = [];
          while (r2 !== null) {
            r0.push(r2);
            r3 = pos;
            if (input.charCodeAt(pos) === 43) {
              r4 = "+";
              pos++;
            } else {
              r4 = null;
              if (reportFailures === 0) {
                matchFailed("\"+\"");
              }
            }
            if (r4 === null) {
              if (input.charCodeAt(pos) === 45) {
                r4 = "-";
                pos++;
              } else {
                r4 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
            }
            if (r4 !== null) {
              r6 = parse_Letter();
              if (r6 !== null) {
                r5 = [];
                while (r6 !== null) {
                  r5.push(r6);
                  r6 = parse_Letter();
                }
              } else {
                r5 = null;
              }
              if (r5 !== null) {
                r2 = [r4, r5];
              } else {
                r2 = null;
                pos = r3;
              }
            } else {
              r2 = null;
              pos = r3;
            }
          }
        } else {
          r0 = null;
        }
        if (r0 !== null) {
          r0 = (function(offset, mode) {
            const modes = new Map();
            modes.set("+", []);
            modes.set("-", []);
            for (let i = 0, l = mode.length, m; i < l; ++i) {
              m = modes.get(mode[i][0]);
              m.push.apply(m, mode[i][1]);
            } 
            return modes;
          })(r1, r0);
        }
        if (r0 === null) {
          pos = r1;
        }
        return r0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})()